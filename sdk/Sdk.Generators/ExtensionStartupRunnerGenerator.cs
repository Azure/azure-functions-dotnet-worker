// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
namespace Microsoft.Azure.Functions.Worker.Sdk.Generators
{
    /// <summary>
    /// Generates a class with a method which has code to call the "Configure" method
    /// of each of the participating extension's "WorkerExtensionStartup" implementations.
    /// Also adds the assembly attribute "WorkerExtensionStartupCodeExecutorInfo"
    /// and pass the information(the type) about the class we generated.
    /// We are also inheriting the generated class from the WorkerExtensionStartup class.
    /// (This is the same abstract class extension authors will implement for their extension specific startup code)
    /// We need the same signature as the extension's implementation as our class is an uber class which internally
    /// calls each of the extension's implementations.
    /// </summary>

    // Sample code generated (with one extensions participating in startup hook)
    // There will be one try-catch block for each extension participating in startup hook.

    //[assembly: WorkerExtensionStartupCodeExecutorInfo(typeof(Microsoft.Azure.Functions.Worker.WorkerExtensionStartupCodeExecutor))]
    //
    //internal class WorkerExtensionStartupCodeExecutor : WorkerExtensionStartup
    //{
    //    public override void Configure(IFunctionsWorkerApplicationBuilder applicationBuilder)
    //    {
    //        try
    //        {
    //            new Microsoft.Azure.Functions.Worker.Extensions.Http.MyHttpExtensionStartup().Configure(applicationBuilder);
    //        }
    //        catch (Exception ex)
    //        {
    //            Console.Error.WriteLine("Error calling Configure on Microsoft.Azure.Functions.Worker.Extensions.Http.MyHttpExtensionStartup instance." + ex.ToString());
    //        }
    //    }
    //}
    [Generator]
    public class ExtensionStartupRunnerGenerator : IIncrementalGenerator
    {
        /// <summary>
        /// The attribute which extension authors will apply on an assembly which contains their startup type.
        /// </summary>
        private const string AttributeTypeName = "WorkerExtensionStartupAttribute";

        /// <summary>
        /// Fully qualified name of the above "WorkerExtensionStartupAttribute" attribute.
        /// </summary>
        private const string AttributeTypeFullName =
            "Microsoft.Azure.Functions.Worker.Core.WorkerExtensionStartupAttribute";

        /// <summary>
        /// Fully qualified name of the base type which extension startup classes should implement.
        /// </summary>
        private const string StartupBaseClassName = "Microsoft.Azure.Functions.Worker.Core.WorkerExtensionStartup";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Get the sub set of assemblies with startup attribute
            var assembliesValueProvider = context.CompilationProvider
                .SelectMany((compilation, token) =>
                    compilation.SourceModule.ReferencedAssemblySymbols
                        .Where(IsAssemblyWithExtensionStartupAttribute));

            // Build a data model for the startup type info & any potential diagnostic errors from it.
            var entriesValueProvider =
                assembliesValueProvider.Select(CreateStartupTypeInfoFromAssemblySymbol);

            var startupTypeEntries = entriesValueProvider.Collect();

            context.RegisterSourceOutput(startupTypeEntries, Execute);
        }

        private static void Execute(SourceProductionContext context,
            ImmutableArray<StartupTypeInfo> assemblySymbols)
        {
            if (assemblySymbols.IsEmpty)
            {
                return;
            }
            
            ReportDiagnosticsIfAny(context, assemblySymbols);

            var extensionStartupTypeNames = assemblySymbols.Where(i => i.Diagnostics.IsEmpty)
                                                           .Select(a => a.StartupTypeName);

            SourceText sourceText;
            using (var stringWriter = new StringWriter())
            using (var indentedTextWriter = new IndentedTextWriter(stringWriter))
            {
                indentedTextWriter.WriteLine("// <auto-generated/>");
                indentedTextWriter.WriteLine("using System;");
                indentedTextWriter.WriteLine("using Microsoft.Azure.Functions.Worker.Core;");
                WriteAssemblyAttribute(indentedTextWriter);
                indentedTextWriter.WriteLine("namespace Microsoft.Azure.Functions.Worker");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;
                WriteStartupCodeExecutorClass(indentedTextWriter, extensionStartupTypeNames);
                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                indentedTextWriter.Flush();
                sourceText = SourceText.From(stringWriter.ToString(), encoding: Encoding.UTF8);
            }

            // Add the source code to the compilation
            context.AddSource($"WorkerExtensionStartupCodeExecutor.g.cs", sourceText);
        }

        private static void ReportDiagnosticsIfAny(SourceProductionContext context,
            ImmutableArray<StartupTypeInfo> startupTypeEntries)
        {
            foreach (var startupTypeEntry in startupTypeEntries)
            {
                foreach (var diagnostic in startupTypeEntry.Diagnostics)
                {
                    context.ReportDiagnostic(diagnostic);
                }
            }
        }

        private static StartupTypeInfo CreateStartupTypeInfoFromType(ITypeSymbol typeSymbol)
        {
            var entry = new StartupTypeInfo { StartupTypeName = typeSymbol.ToDisplayString() };

            var builder = ImmutableArray.CreateBuilder<Diagnostic>();

            if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
            {
                // Check public parameterless constructor exist for the type.
                var constructorExist = namedTypeSymbol.InstanceConstructors
                    .Any(c => c.Parameters.Length == 0 &&
                              c.DeclaredAccessibility == Accessibility.Public);
                if (!constructorExist)
                {
                    var diagnostic = Diagnostic.Create(DiagnosticDescriptors.ConstructorMissing, Location.None,
                        typeSymbol.ToDisplayString());
                    builder.Add(diagnostic);
                }

                // Check the extension startup class implements WorkerExtensionStartup abstract class.
                if (!namedTypeSymbol.BaseType!.GetFullName().Equals(StartupBaseClassName, StringComparison.Ordinal))
                {
                    var diagnostic = Diagnostic.Create(DiagnosticDescriptors.IncorrectBaseType, Location.None,
                        typeSymbol.ToDisplayString(), StartupBaseClassName);
                    builder.Add(diagnostic);
                }
            }

            entry.Diagnostics = builder.ToImmutable();

            return entry;
        }

        /// <summary>
        /// Writes an assembly attribute with type information about our auto generated WorkerExtensionStartupCodeExecutor class.
        /// </summary>
        private static void WriteAssemblyAttribute(IndentedTextWriter textWriter)
        {
            textWriter.WriteLine(
                "[assembly: WorkerExtensionStartupCodeExecutorInfo(typeof(Microsoft.Azure.Functions.Worker.WorkerExtensionStartupCodeExecutor))]");
        }

        private static void WriteStartupCodeExecutorClass(IndentedTextWriter textWriter,
            IEnumerable<string> startupTypeNames)
        {
            textWriter.WriteLine("internal class WorkerExtensionStartupCodeExecutor : WorkerExtensionStartup");
            textWriter.WriteLine("{");
            textWriter.Indent++;
            textWriter.WriteLine(
                "public override void Configure(IFunctionsWorkerApplicationBuilder applicationBuilder)");
            textWriter.WriteLine("{");
            textWriter.Indent++;

            foreach (var typeName in startupTypeNames)
            {
                textWriter.WriteLine("try");
                textWriter.WriteLine("{");
                textWriter.Indent++;

                textWriter.WriteLine($"new {typeName}().Configure(applicationBuilder);");

                textWriter.Indent--;
                textWriter.WriteLine("}");
                textWriter.WriteLine("catch (Exception ex)");
                textWriter.WriteLine("{");
                textWriter.Indent++;
                textWriter.WriteLine($"Console.Error.WriteLine(\"Error calling Configure on {typeName} instance.\"+ex.ToString());");
                textWriter.Indent--;
                textWriter.WriteLine("}");
            }

            textWriter.Indent--;
            textWriter.WriteLine("}");
            textWriter.Indent--;
            textWriter.WriteLine("}");
        }

        private static bool IsAssemblyWithExtensionStartupAttribute(IAssemblySymbol arg)
        {
            var extensionStartupAttribute = GetStartupAttributeData(arg);

            return extensionStartupAttribute != null;
        }

        private static AttributeData? GetStartupAttributeData(IAssemblySymbol assemblySymbol)
        {
            var extensionStartupAttribute = assemblySymbol.GetAttributes()
                .FirstOrDefault(a =>
                    (a.AttributeClass?.Name.Equals(AttributeTypeName,
                        StringComparison.Ordinal) ?? false) &&
                    //Call GetFullName only if class name matches.
                    a.AttributeClass.GetFullName()
                        .Equals(AttributeTypeFullName, StringComparison.Ordinal)
                );

            return extensionStartupAttribute;
        }

        /// <summary>
        /// Build an instance of StartupTypeInfo from the assembly symbol.
        /// </summary>
        private static StartupTypeInfo CreateStartupTypeInfoFromAssemblySymbol(IAssemblySymbol assemblySymbol,
            CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            
            var extensionStartupAttribute = GetStartupAttributeData(assemblySymbol);
            if (extensionStartupAttribute is null)
            {
                return default;
            }

            // WorkerExtensionStartupAttribute has a constructor with one param, the type of startup implementation class.
            var firstConstructorParam = extensionStartupAttribute.ConstructorArguments[0];
            if (firstConstructorParam.Value is not ITypeSymbol typeSymbol)
            {
                return default;
            }

            return CreateStartupTypeInfoFromType(typeSymbol);
        }
        
        /// <summary>
        /// A type to represent the data about the extension startup types we want to generate code for.
        /// </summary>
        private struct StartupTypeInfo
        {
            /// <summary>
            /// The full type name.
            /// ex: Microsoft.Azure.Functions.Worker.Extensions.DurableTask.DurableTaskExtensionStartup
            /// </summary>
            internal string StartupTypeName { get; set; }
            
            /// <summary>
            /// A collection of diagnostic entries associated with this startup type.
            /// </summary>
            internal ImmutableArray<Diagnostic> Diagnostics { get; set; } 
        }
    }
}
