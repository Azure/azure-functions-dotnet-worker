// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using System.Threading;

namespace Microsoft.Azure.Functions.Worker.Sdk.Generators
{
    public partial class FunctionMetadataProviderGenerator
    {
        internal sealed class Emitter
        {
            private static readonly JsonSerializerOptions _jsonOptions = new()
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                DictionaryKeyPolicy = JsonNamingPolicy.CamelCase
            };

            public string Emit(IReadOnlyList<GeneratorFunctionMetadata> funcMetadata, CancellationToken cancellationToken)
            {
                string functionMetadataInfo = AddFunctionMetadataInfo(funcMetadata, cancellationToken);

                return $$"""
                         // <auto-generated/>
                         using System;
                         using System.Collections.Generic;
                         using System.Collections.Immutable;
                         using System.Text.Json;
                         using System.Threading.Tasks;
                         using Microsoft.Azure.Functions.Worker.Core.FunctionMetadata;
                         using Microsoft.Azure.Functions.Worker.Http;
                         using Microsoft.Extensions.DependencyInjection;
                         using Microsoft.Extensions.Hosting;
                     
                         namespace Microsoft.Azure.Functions.Worker
                         {
                             public class GeneratedFunctionMetadataProvider : IFunctionMetadataProvider
                             {
                                 public Task<ImmutableArray<IFunctionMetadata>> GetFunctionMetadataAsync(string directory)
                                 {
                                     var metadataList = new List<IFunctionMetadata>();
                         {{functionMetadataInfo}}
                                     return Task.FromResult(metadataList.ToImmutableArray());
                                 }
                             }
                     
                             public static class WorkerHostBuilderFunctionMetadataProviderExtension
                             {
                                 ///<summary>
                                 /// Adds the GeneratedFunctionMetadataProvider to the service collection.
                                 /// During initialization, the worker will return generated function metadata instead of relying on the Azure Functions host for function indexing.
                                 ///</summary>
                                 public static IHostBuilder ConfigureGeneratedFunctionMetadataProvider(this IHostBuilder builder)
                                 {
                                     builder.ConfigureServices(s => 
                                     {
                                         s.AddSingleton<IFunctionMetadataProvider, GeneratedFunctionMetadataProvider>();
                                     });
                                     return builder;
                                 }
                             }
                         }
                         """;
            }

            private string AddFunctionMetadataInfo(IReadOnlyList<GeneratorFunctionMetadata> functionMetadata, CancellationToken cancellationToken)
            {
                var functionCount = 0;
                var builder = new StringBuilder();

                foreach (var function in functionMetadata)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    // we're going to base variable names on Function[Num] because some function names have characters we can't use for a dotnet variable
                    var functionVariableName = "Function" + functionCount.ToString();
                    var functionBindingsListVarName = functionVariableName + "RawBindings";
                    var bindingInfo = AddBindingInfo(functionBindingsListVarName, function.RawBindings);

                    builder.AppendLine(
                    $$"""
                                 var {{functionBindingsListVarName}} = new List<string>();
                     {{bindingInfo}}
                                 var {{functionVariableName}} = new DefaultFunctionMetadata
                                 {
                                     Language = "dotnet-isolated",
                                     Name = "{{function.Name}}",
                                     EntryPoint = "{{function.EntryPoint}}",
                                     RawBindings = {{functionBindingsListVarName}},
                                     ScriptFile = "{{function.ScriptFile}}"
                                 };
                                 metadataList.Add({{functionVariableName}});
                     """);

                    functionCount++;
                }

                return builder.ToString();
            }

            private string AddBindingInfo(string bindingListVariableName, IList<IDictionary<string, object>> bindings)
            {
                var builder = new StringBuilder();
                foreach (var binding in bindings)
                {
                    var jsonBinding = JsonSerializer.Serialize(binding, _jsonOptions);
                    builder.AppendLine($"""            {bindingListVariableName}.Add(@"{jsonBinding.Replace("\"", "\"\"")}");""");
                }

                return builder.ToString();
            }
        }

    }
}
