using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.Azure.Functions.Worker.Sdk.Generators
{
    /// <summary>
    /// Generates a class that implements IFunctionMetadataProvider and the method GetFunctionsMetadataAsync() which returns a list of IFunctionMetadata. 
    /// This source generator indexes a Function App and explicitly creates a list of DefaultFunctionMetadata (which implements IFunctionMetadata) from the functions defined
    /// in the user's compilation. This allows the worker to index functions at build time, rather than waiting for the process to start.
    /// </summary>
    [Generator]
    public class FunctionMetadataProviderGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            // retreive the populated receiver 
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            Compilation compilation = context.Compilation;

            SourceText sourceText;
            using (var stringWriter = new StringWriter())
            using (var indentedTextWriter = new IndentedTextWriter(stringWriter))
            {
                // set up usings
                indentedTextWriter.WriteLine("// <auto-generated/>");
                indentedTextWriter.WriteLine("using System;");
                indentedTextWriter.WriteLine("using System.Collections.Generic;");
                indentedTextWriter.WriteLine("using System.Collections.Immutable;");
                indentedTextWriter.WriteLine("using System.Text.Json;");
                indentedTextWriter.WriteLine("using System.Threading.Tasks;");
                indentedTextWriter.WriteLine("using Microsoft.Azure.Functions.Core;");
                indentedTextWriter.WriteLine("using Microsoft.Azure.Functions.Worker.Core.FunctionMetadata;");
                indentedTextWriter.WriteLine("using Microsoft.Extensions.DependencyInjection;");
                indentedTextWriter.WriteLine("using Microsoft.Extensions.Hosting;");

                // create namespace
                indentedTextWriter.WriteLine("namespace Microsoft.Azure.Functions.Worker");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;

                // create class that implements IFunctionMetadataProvider
                indentedTextWriter.WriteLine("public class GeneratedFunctionMetadataProvider : IFunctionMetadataProvider");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;

                WriteGetFunctionsMetadataAsyncMethod(indentedTextWriter, receiver, compilation);
                AddEnumTypes(indentedTextWriter);

                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                // add method that users can call in startup to register the source-generated file
                AddRegistrationExtension(indentedTextWriter);

                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                indentedTextWriter.Flush();
                sourceText = SourceText.From(stringWriter.ToString(), encoding: Encoding.UTF8);
            }

            // Add the source code to the compilation
            context.AddSource($"GeneratedFunctionMetadataProvider.g.cs", sourceText);
        }

        private static void WriteGetFunctionsMetadataAsyncMethod(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation)
        {
            indentedTextWriter.WriteLine("public Task<ImmutableArray<IFunctionMetadata>> GetFunctionMetadataAsync(string directory)");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            // create list of IFunctionMetadata and populate it
            indentedTextWriter.WriteLine("var metadataList = new List<IFunctionMetadata>();");
            AddFunctionMetadataInfo(indentedTextWriter, receiver, compilation);
            indentedTextWriter.WriteLine("return Task.FromResult(metadataList.ToImmutableArray());");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        private static void AddFunctionMetadataInfo(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation)
        {
            var assemblyName = compilation.Assembly.Name;
            var scriptFile = Path.Combine(assemblyName + ".dll");

            // Loop through the candidate methods (these are mthods suspected to be Functions, stored in the SyntaxReceiver)
            foreach (MethodDeclarationSyntax method in receiver.CandidateMethods)
            {
                var functionClass = (ClassDeclarationSyntax)method.Parent!;
                var functionName = functionClass.Identifier.ValueText;
                var entryPoint = assemblyName + "." + functionName + "." + method.Identifier.ValueText;
                var bindingsListName = functionName + "RawBindings";

                // collect Bindings
                indentedTextWriter.WriteLine($"var {bindingsListName} = new List<string>();");
                AddBindingInfo(indentedTextWriter, method, compilation, functionName);
                indentedTextWriter.WriteLine($"var {functionName} = new DefaultFunctionMetadata(Guid.NewGuid().ToString(), \"dotnet-isolated\", \"{functionName}\", \"{entryPoint}\", {functionName}RawBindings, \"{scriptFile}\");");
                indentedTextWriter.WriteLine($"metadataList.Add({functionName});");
            }
        }

        private static void AddBindingInfo(IndentedTextWriter indentedTextWriter, MethodDeclarationSyntax method, Compilation compilation, string functionName)
        {
            var model = compilation.GetSemanticModel(method.SyntaxTree);
            var bindingCount = 0;
            var bindingsListName = functionName + "RawBindings";

            // Loop through the parameters in this Function to find the bindings
            foreach (ParameterSyntax parameter in method.ParameterList.Parameters)
            {
                // If there's no attribute, we can assume that this parameter is not a binding
                if (parameter.AttributeLists.Count == 0)
                {
                    continue;
                }

                IParameterSymbol? parameterSymbol = model.GetDeclaredSymbol(parameter);

                if (parameterSymbol is null)
                {
                    throw new InvalidOperationException($"The symbol for the parameter '{nameof(parameter)}' could not be found");
                }

                // Assumption: All parameters in a function method thathave an attribute will have just one (the trigger or input/output binding attribute)
                AttributeData attributeData = parameterSymbol.GetAttributes().First();

                // Get the attribute method symbol and treat the constructor as a method (IMethodSymbol)
                AttributeSyntax attributeSyntax = parameter.AttributeLists.First().Attributes.First();
                IMethodSymbol? attribMethodSymbol = model.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;

                // Check if the attribute constructor has any parameters
                if (attribMethodSymbol is null || attribMethodSymbol?.Parameters is null)
                {
                    throw new InvalidOperationException($"The constructor of attribute with syntax '{nameof(attributeSyntax)}' is invalid");
                }

                // Get binding info as a dictionary with keys as the property name and value as the property value
                IDictionary<string, object> attributeProperties = GetAttributeProperties(attribMethodSymbol, attributeData);

                // Grab some required binding info properties
                string attributeName = attributeData.AttributeClass!.Name;
                string bindingName = parameter.Identifier.ValueText;

                // properly format binding types by removing "Attribute" and "Input" descriptors
                string bindingType = attributeName.Replace("Attribute", "");
                bindingType = bindingType.Replace("Input", "");

                // Set binding direction
                string bindingDirection = "In";
                if (parameterSymbol.Type is INamedTypeSymbol parameterNamedType &&
                    parameterNamedType.IsGenericType &&
                    parameterNamedType.ConstructUnboundGenericType().ToString() == "Microsoft.Azure.Functions.DotNetWorker.OutputBinding<>")
                {
                    bindingDirection = "Out";
                }

                // Create raw binding anonymous type, example:
                /*  var binding1 = new {
                    name = "req",
                    type = "HttpTrigger",
                    direction = "In",
                    authLevel = Enum.GetName(typeof(AuthorizationLevel),0),
                    methods = new List<string> { "get","post" },
                };*/
                indentedTextWriter.WriteLine($"var {functionName}Binding" + bindingCount.ToString() + " = new {"); // give each binding unique name of functionName + "binding" + number
                indentedTextWriter.Indent++;
                indentedTextWriter.WriteLine($"name = \"{ bindingName}\",");
                indentedTextWriter.WriteLine($"type = \"{bindingType}\",");
                indentedTextWriter.WriteLine($"direction = \"{bindingDirection}\",");

                // Add additional bindingInfo to the anonymous type because some functions have more properties than others
                foreach (var prop in attributeProperties)
                {
                    var propertyName = prop.Key;

                    if (prop.Value.GetType().IsArray)
                    {
                        string arr = FormatArray((IEnumerable)prop.Value);
                        indentedTextWriter.WriteLine($"{propertyName} = {arr},");
                    }
                    else
                    {
                        var propertyValue = FormatObject(prop.Value);
                        indentedTextWriter.WriteLine($"{propertyName} = {propertyValue},");
                    }
                }

                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("};");

                // Take the anonymous type representing the binding and serialize it as a JSON string
                indentedTextWriter.WriteLine($"var {functionName}Binding" + bindingCount.ToString() + $"JSONstring = JsonSerializer.Serialize({functionName}Binding" + bindingCount.ToString() + ");");
                indentedTextWriter.WriteLine($"{bindingsListName}.Add({ functionName}Binding" + bindingCount.ToString() + "JSONstring);");

                bindingCount++;

                // auto-add a return type for http for now
                if (string.Equals(bindingType, "httptrigger", StringComparison.OrdinalIgnoreCase))
                {
                    var totalBindings = method.ParameterList.Parameters.Count(param => param.AttributeLists.Count > 0);

                    indentedTextWriter.WriteLine($"var {functionName}Binding" + bindingCount.ToString() + " = new {");
                    indentedTextWriter.Indent++;

                    // if there are only two bindings and one is an httptrigger, then we use "$return" for the binding name
                    if (totalBindings < 2)
                    {
                        indentedTextWriter.WriteLine("name = \"$return\",");
                    }
                    else
                    {
                        // when there are more than 2 bindings and one is an HttpTrigger, we can assume that there is another output binding
                        // we return HttpResponse instead of "$return"
                        indentedTextWriter.WriteLine("name = \"HttpResponse\",");
                    }

                    indentedTextWriter.WriteLine("type = \"http\",");
                    indentedTextWriter.WriteLine("direction = \"Out\",");
                    indentedTextWriter.Indent--;
                    indentedTextWriter.WriteLine("};");
                    indentedTextWriter.WriteLine($"var {functionName}Binding" + bindingCount.ToString() + $"JSONstring = JsonSerializer.Serialize({functionName}Binding" + bindingCount.ToString() + ");");
                    indentedTextWriter.WriteLine($"{functionName}RawBindings.Add({functionName}Binding" + bindingCount.ToString() + "JSONstring);");
                    bindingCount++;
                }
            }
        }

        private static void AddEnumTypes(IndentedTextWriter indentedTextWriter)
        {
            indentedTextWriter.WriteLine("public enum AuthorizationLevel");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("Anonymous,");
            indentedTextWriter.WriteLine("User,");
            indentedTextWriter.WriteLine("Function,");
            indentedTextWriter.WriteLine("System,");
            indentedTextWriter.WriteLine("Admin");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        // adds a generated registration extension that users can call to register the source-generated function metadata provider
        private static void AddRegistrationExtension(IndentedTextWriter indentedTextWriter)
        {
            indentedTextWriter.WriteLine("public static class WorkerHostBuilderFunctionMetadataProviderExtension");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("public static IHostBuilder ConfigureGeneratedFunctionMetadataProvider(this IHostBuilder builder)");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("builder.ConfigureServices(s => ");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("s.AddSingleton<IFunctionMetadataProvider, GeneratedFunctionMetadataProvider>();");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("});");
            indentedTextWriter.WriteLine("return builder;");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        /// <summary>
        /// Register a factory that can create our custom syntax receiver
        /// </summary>
        /// <param name="context"></param>
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        /// <summary>
        /// Created on demand before each generation pass
        /// </summary>
        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<MethodDeclarationSyntax> CandidateMethods { get; } = new List<MethodDeclarationSyntax>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is MethodDeclarationSyntax methodSyntax)
                {
                    foreach (var p in methodSyntax.ParameterList.Parameters)
                    {
                        if (p.AttributeLists.Count > 0)
                        {
                            CandidateMethods.Add(methodSyntax);
                            break;
                        }
                    }
                }
            }
        }

        internal static IDictionary<string, object> GetAttributeProperties(IMethodSymbol attribMethodSymbol, AttributeData attributeData)
        {
            Dictionary<string, object> argumentData = new();
            if (attributeData.ConstructorArguments.Any())
            {
                LoadConstructorArguments(attribMethodSymbol, attributeData, argumentData);
            }

            foreach (var namedArgument in attributeData.NamedArguments)
            {
                if (namedArgument.Value.Value != null)
                {
                    argumentData[namedArgument.Key] = namedArgument.Value.Value;
                }
            }

            return argumentData;
        }

        internal static void LoadConstructorArguments(IMethodSymbol attribMethodSymbol, AttributeData attributeData, IDictionary<string, object> dict)
        {
            if (attribMethodSymbol.Parameters.Length < attributeData.ConstructorArguments.Length)
            {
                throw new InvalidOperationException($"The constructor at '{nameof(attribMethodSymbol)}' has less total arguments than '{nameof(attributeData)}'.");
            }

            // It's fair to assume than constructor arguments appear before named arguments, and
            // that the constructor names would match the property names
            for (int i = 0; i < attributeData.ConstructorArguments.Length; i++)
            {
                var argumentName = attribMethodSymbol.Parameters[i].Name;

                var arg = attributeData.ConstructorArguments[i];
                switch (arg.Kind)
                {
                    case TypedConstantKind.Error:
                        break;
                    case TypedConstantKind.Primitive:
                        dict[argumentName] = arg.Value;
                        break;
                    case TypedConstantKind.Enum:
                        dict[argumentName] = "Enum.GetName(typeof(" + arg.Type!.Name.ToString() + "), " + arg.Value + ")";
                        break;
                    case TypedConstantKind.Type:
                        break;
                    case TypedConstantKind.Array:
                        var arrayValues = arg.Values.Select(a => a.Value!.ToString()).ToArray();
                        dict[argumentName] = arrayValues;
                        break;
                    default:
                        break;
                }
            }
        }

        internal static string FormatObject(object propValue)
        {
            if (propValue != null)
            {
                // catch values that are already strings or Enum parsing
                // we don't need to surround these cases with quotation marks
                if (propValue.ToString().Contains("\"") || propValue.ToString().Contains("Enum"))
                {
                    return propValue.ToString();
                }

                return "\"" + propValue.ToString() + "\"";
            }
            else
            {
                return "null";
            }
        }

        internal static string FormatArray(IEnumerable enumerableValues)
        {
            string arrAsString;

            arrAsString = "new List<string> { ";

            foreach (var o in enumerableValues)
            {
                arrAsString += FormatObject(o);
                arrAsString += ",";
            }

            arrAsString = arrAsString.TrimEnd(',', ' ');
            arrAsString += " }";

            return arrAsString;
        }
    }
}
