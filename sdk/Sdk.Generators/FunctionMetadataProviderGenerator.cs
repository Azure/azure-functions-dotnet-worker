using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;


namespace Microsoft.Azure.Functions.Worker.Sdk.Generators
{
    [Generator]
    public class FunctionMetadataProviderGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            // retreive the populated receiver 
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            Compilation compilation = context.Compilation;

            SourceText sourceText;
            using (var stringWriter = new StringWriter())
            using (var indentedTextWriter = new IndentedTextWriter(stringWriter))
            {
                indentedTextWriter.WriteLine("// <auto-generated/>");
                indentedTextWriter.WriteLine("using System;");
                indentedTextWriter.WriteLine("using System.Collections.Generic;");
                indentedTextWriter.WriteLine("using System.Collections.Immutable;");
                indentedTextWriter.WriteLine("using System.Threading.Tasks;");
                indentedTextWriter.WriteLine("using Microsoft.Azure.Functions.Worker.Grpc.Messages;");
                indentedTextWriter.WriteLine("namespace Microsoft.Azure.Functions.Worker.Grpc");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;
                indentedTextWriter.WriteLine("internal class DefaultFunctionMetadataProvider : IFunctionMetadataProvider");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;
                WriteGetFunctionsMetadataAsyncMethod(indentedTextWriter, receiver, compilation);
                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");
                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                indentedTextWriter.Flush();
                sourceText = SourceText.From(stringWriter.ToString(), encoding: Encoding.UTF8);
            }

            // Add the source code to the compilation
            context.AddSource($"SourceGeneratedFunctionMetadataProvider.g.cs", sourceText);
        }

        private static void WriteGetFunctionsMetadataAsyncMethod(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation)
        {
            indentedTextWriter.WriteLine("public virtual async Task<ImmutableArray<RpcFunctionMetadata>> GetFunctionMetadataAsync(string directory)");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("var metadataList = new List<RpcFunctionMetadata>();");
            AddFunctionMetadataInfo(indentedTextWriter, receiver, compilation);
            indentedTextWriter.WriteLine("return Task.FromResult(metadataList.ToImmutableArray());");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        private static void AddFunctionMetadataInfo(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation)
        {
            var assemblyName = compilation.Assembly.Name;
            var scriptFile = Path.Combine("bin/" + assemblyName + ".dll");

            foreach (MethodDeclarationSyntax method in receiver.CandidateMethods)
            {

                var functionClass = (ClassDeclarationSyntax)method.Parent!;
                var functionName = functionClass.Identifier.ValueText;
                var entryPoint = assemblyName + "." + functionName + "." + method.Identifier.ValueText;

                indentedTextWriter.WriteLine("var " + functionName + "= new RpcFunctionMetadata();");
                indentedTextWriter.WriteLine(functionName + ".Name = \"" + functionName + "\";");
                indentedTextWriter.WriteLine(functionName + ".ScriptFile = \"" + scriptFile + "\";");
                indentedTextWriter.WriteLine(functionName + ".Language = \"dotnet-isolated\";");
                indentedTextWriter.WriteLine(functionName + ".EntryPoint = \"" + entryPoint + "\";");
                indentedTextWriter.WriteLine(functionName + ".IsProxy = false;");
                indentedTextWriter.WriteLine(functionName + ".FunctionId = Guid.NewGuid().ToString();");
                // do I need to add Properties { isCodeless: false} or no? Seems to be auto-generated in the loader.
                AddBindingInfo(indentedTextWriter, method, compilation, functionName);
                indentedTextWriter.WriteLine("metadataList.Add(" + functionName + ");");
            }

        }

        private static void AddBindingInfo(IndentedTextWriter indentedTextWriter, MethodDeclarationSyntax method, Compilation compilation, string functionName)
        {
            var model = compilation.GetSemanticModel(method.SyntaxTree);

            foreach (ParameterSyntax parameter in method.ParameterList.Parameters)
            {
                // If there's no attribute, we can assume that this parameter is not a binding
                if (parameter.AttributeLists.Count == 0)
                {
                    continue;
                }

                // Get the parameter symbol and grab the first attribute
                // We are assuming that any function that has an attribute has only one (the input/output binding or trigger)
                IParameterSymbol parameterSymbol = model.GetDeclaredSymbol(parameter) as IParameterSymbol;
                AttributeData attributeData = parameterSymbol.GetAttributes().First();

                // Get the attribute syntax and treat the constructor as a method (IMethodSymbol)
                AttributeSyntax attributeSyntax = parameter.AttributeLists.First().Attributes.First();
                IMethodSymbol attribMethodSymbol = model.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;

                // Check if the constructor has any parameters
                if (attribMethodSymbol?.Parameters is null)
                {
                    throw new InvalidOperationException($"The constructor of attribute with syntax '{nameof(attributeSyntax)}' is invalid");
                }

                // Get binding info as a dictionary with keys as the property name and value as the property value
                IDictionary<string, object> attributeProperties = GetAttributeProperties(attribMethodSymbol, attributeData);

                // Create binding metadata w/ info below and add to function metadata created above
                string attributeName = attributeData.AttributeClass!.Name; // TODO: Verify if we can ever have an attribute with no AttributeClass (it is null)
                string bindingName = parameter.Identifier.ValueText; // correct?
                string bindingType = attributeName.Replace("Attribute", "");

                // Set binding direction
                // TODO: InOut?
                string bindingDirection = "In";
                if (parameterSymbol.Type is INamedTypeSymbol parameterNamedType &&
                    parameterNamedType.IsGenericType &&
                    parameterNamedType.ConstructUnboundGenericType().ToString() == "Microsoft.Azure.Functions.DotNetWorker.OutputBinding<>")
                {
                    bindingDirection = "Out";
                }

                // Create raw binding anonymous type, example:
                /*  var binding1 = new {
                    name = "req",
                    type = "httpTrigger",
                    direction = "In",
                    authLevel = "Anonymous",
                    methods = new List<string> { "get", "post" }
                };*/
                indentedTextWriter.WriteLine("var " + bindingName + " = new {");
                indentedTextWriter.Indent++;
                indentedTextWriter.WriteLine("name = \"" + bindingName + "\",");
                indentedTextWriter.WriteLine("type = \"" + bindingType + "\",");
                indentedTextWriter.WriteLine("direction = \"" + bindingDirection + "\",");

                // Add any additional binding info to the anonymous type
                foreach (var prop in attributeProperties)
                {
                    var propertyName = prop.Key;

                    if (prop.Value.GetType().IsArray)
                    {
                        string arr = FormatArray(prop.Value as IEnumerable);
                        indentedTextWriter.WriteLine(propertyName + " = " + arr + ",");
                    }
                    else
                    {
                        var propertyValue = FormatObject(prop.Value);
                        indentedTextWriter.WriteLine(propertyName + " = " + propertyValue + ",");
                    }
                }

                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("};");

                indentedTextWriter.WriteLine(functionName + ".RawBindings.Add(JsonSerializer.Serialize(" + bindingName + "));");

                // Create BindingInfo and add to function metadata
                indentedTextWriter.WriteLine("var bindingInfo" + bindingName + " = new BindingInfo()");
                indentedTextWriter.WriteLine("Enum.TryParse(" + bindingName + ".direction, out BindingInfo.Types.Direction direction);");
                indentedTextWriter.WriteLine("bindingInfo" + bindingName + ".Direction = direction;");
                indentedTextWriter.WriteLine("bindingInfo" + bindingName + ".Type = " + bindingName + ".type;");
                indentedTextWriter.WriteLine(functionName + ".Bindings.Add(" + bindingName + ".name, bindingInfo" + bindingName + ");");
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        /// <summary>
        /// Created on demand before each generation pass
        /// </summary>
        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<MethodDeclarationSyntax> CandidateMethods { get; } = new List<MethodDeclarationSyntax>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is MethodDeclarationSyntax methodSyntax)
                {
                    foreach (var p in methodSyntax.ParameterList.Parameters)
                    {
                        if (p.AttributeLists.Count > 0)
                        {
                            CandidateMethods.Add(methodSyntax);
                            break;
                        }
                    }
                }
            }
        }

        internal static IDictionary<string, object> GetAttributeProperties(IMethodSymbol attribMethodSymbol, AttributeData attributeData)
        {
            Dictionary<string, object> argumentData = new();
            if (attributeData.ConstructorArguments.Any())
            {
                LoadConstructorArguments(attribMethodSymbol, attributeData, argumentData);
            }

            foreach (var namedArgument in attributeData.NamedArguments)
            {
                if (namedArgument.Value.Value != null)
                {
                    argumentData[namedArgument.Key] = namedArgument.Value.Value;
                }
            }

            return argumentData;
        }

        internal static void LoadConstructorArguments(IMethodSymbol attribMethodSymbol, AttributeData attributeData, IDictionary<string, object> dict)
        {
            if (attribMethodSymbol.Parameters.Length < attributeData.ConstructorArguments.Length)
            {
                throw new InvalidOperationException($"The constructor at '{nameof(attribMethodSymbol)}' has less total arguments than '{nameof(attributeData)}'.");
            }

            // It's fair to assume than constructor arguments appear before named arguments, and
            // that the constructor names would match the property names
            for (int i = 0; i < attributeData.ConstructorArguments.Length; i++)
            {
                var argumentName = attribMethodSymbol.Parameters[i].Name;

                var arg = attributeData.ConstructorArguments[i];
                switch (arg.Kind)
                {
                    case TypedConstantKind.Error:
                        break;
                    case TypedConstantKind.Primitive:
                    case TypedConstantKind.Enum:
                        //Enum.GetName( , arg.Value);
                        dict[argumentName] = arg.Value;
                        break;
                    case TypedConstantKind.Type:
                        break;
                    case TypedConstantKind.Array:
                        var arrayValues = arg.Values.Select(a => a.Value.ToString()).ToArray();
                        dict[argumentName] = arrayValues;
                        break;
                    default:
                        break;
                }
            }
        }

        private static string FormatObject(object propValue)
        {
            if (propValue != null)
            {
                if (propValue.ToString().Contains("\""))
                {
                    return propValue.ToString();
                }

                return "\"" + propValue.ToString() + "\"";
            }
            else
            {
                return "null";
            }
        }

        // TODO: verify what arrays show up in functions metadata
        // is it just "methods" property for http triggers?
        private static string FormatArray(IEnumerable enumerableValues)
        {
            string arrAsString;

            arrAsString = "[";

            foreach (var o in enumerableValues)
            {
                arrAsString += FormatObject(o);
                arrAsString += ",";
            }

            arrAsString = arrAsString.TrimEnd(',', ' ');
            arrAsString += "]";

            return arrAsString;
        }
    }
}
