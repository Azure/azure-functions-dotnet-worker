using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Azure.Functions.Worker.Sdk.Generators.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.Azure.Functions.Worker.Sdk.Generators
{
    /// <summary>
    /// Generates a class that implements IFunctionMetadataProvider and the method GetFunctionsMetadataAsync() which returns a list of IFunctionMetadata. 
    /// This source generator indexes a Function App and explicitly creates a list of DefaultFunctionMetadata (which implements IFunctionMetadata) from the functions defined
    /// in the user's compilation. This allows the worker to index functions at build time, rather than waiting for the process to start.
    /// </summary>
    [Generator]
    public class FunctionMetadataProviderGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            // retreive the populated receiver 
            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
                return;

            Compilation compilation = context.Compilation;

            SourceText sourceText;
            using (var stringWriter = new StringWriter())
            using (var indentedTextWriter = new IndentedTextWriter(stringWriter))
            {
                // set up usings
                indentedTextWriter.WriteLine("// <auto-generated/>");
                indentedTextWriter.WriteLine("using System;");
                indentedTextWriter.WriteLine("using System.Collections.Generic;");
                indentedTextWriter.WriteLine("using System.Collections.Immutable;");
                indentedTextWriter.WriteLine("using System.Text.Json;");
                indentedTextWriter.WriteLine("using System.Threading.Tasks;");
                indentedTextWriter.WriteLine("using Microsoft.Azure.Functions.Core;");
                indentedTextWriter.WriteLine("using Microsoft.Azure.Functions.Worker.Core.FunctionMetadata;");
                indentedTextWriter.WriteLine("using Microsoft.Extensions.DependencyInjection;");
                indentedTextWriter.WriteLine("using Microsoft.Extensions.Hosting;");

                // create namespace
                indentedTextWriter.WriteLine("namespace Microsoft.Azure.Functions.Worker");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;

                // create class that implements IFunctionMetadataProvider
                indentedTextWriter.WriteLine("public class GeneratedFunctionMetadataProvider : IFunctionMetadataProvider");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;

                WriteGetFunctionsMetadataAsyncMethod(indentedTextWriter, receiver, compilation, context);
                AddEnumTypes(indentedTextWriter);

                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                // add method that users can call in startup to register the source-generated file
                AddRegistrationExtension(indentedTextWriter);

                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                indentedTextWriter.Flush();
                sourceText = SourceText.From(stringWriter.ToString(), encoding: Encoding.UTF8);
            }
            // Add the source code to the compilation
            context.AddSource($"GeneratedFunctionMetadataProvider.g.cs", sourceText);
        }

        /// <summary>
        /// Register a factory that can create our custom syntax receiver
        /// </summary>
        /// <param name="context"></param>
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        /// <summary>
        /// This method populates a dictionary with argumentName (keys) and argumentValue (value) pairs given attribMethodSymbol, which
        /// represents the attribute constructor as as an IMethodSymbol, and attributeData which stores constructor argument values.
        /// </summary>
        /// <param name="attribMethodSymbol">The attribute's constructor as an IMethodSymbol.</param>
        /// <param name="attributeData">Contains constructor arguments for the constructor represented in attribMethodSymbol.</param>
        /// <param name="dict">A dicitonary to be populated with constructor arguments.</param>
        /// <exception cref="InvalidOperationException"></exception>
        private static void LoadConstructorArguments(IMethodSymbol attribMethodSymbol, AttributeData attributeData, GeneratorExecutionContext context, IDictionary<string, object> dict)
        {
            if (attribMethodSymbol.Parameters.Length != attributeData.ConstructorArguments.Length)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ArgumentCountMismatch, Location.None, new object[] { nameof(attribMethodSymbol) , nameof(attributeData) }));
                return;
            }

            // It's fair to assume than constructor arguments appear before named arguments, and
            // that the constructor names would match the property names
            for (int i = 0; i < attributeData.ConstructorArguments.Length; i++)
            {
                var argumentName = attribMethodSymbol.Parameters[i].Name;
                var arg = attributeData.ConstructorArguments[i];

                switch (arg.Kind)
                {
                    case TypedConstantKind.Error:
                        break;
                    case TypedConstantKind.Primitive:
                        dict[argumentName] = arg.Value;
                        break;
                    case TypedConstantKind.Enum:
                        dict[argumentName] = $"(AuthorizationLevel){arg.Value}"; // the only enum type we have in function metadata is authlevel
                        break;
                    case TypedConstantKind.Type:
                        break;
                    case TypedConstantKind.Array:
                        var arrayValues = arg.Values.Select(a => a.Value!.ToString()).ToArray();
                        dict[argumentName] = arrayValues;
                        break;
                    default:
                        break;
                }
            }
        }

        /// <summary>
        /// Formats an object into a string value for the source-generated file. This can mean adding quotation marks around the string
        /// representation of the object, or leaving it as is if the object is a string or Enum type.
        /// </summary>
        /// <param name="propValue">The property that needs to be formmated into a string.</param>
        /// <returns></returns>
        internal static string FormatObject(object propValue)
        {
            if (propValue != null)
            {
                // catch values that are already strings or Enum parsing
                // we don't need to surround these cases with quotation marks
                if (propValue.ToString().Contains("\"") || propValue.ToString().Contains("AuthorizationLevel"))
                {
                    return propValue.ToString();
                }

                return "\"" + propValue.ToString() + "\"";
            }
            else
            {
                return "null";
            }
        }

        /// <summary>
        /// Format an array into a string.
        /// </summary>
        /// <param name="enumerableValues">An array object to be formatted.</param>
        /// <returns></returns>
        internal static string FormatArray(IEnumerable enumerableValues)
        {
            string arrAsString;

            arrAsString = "new List<string> { ";

            foreach (var o in enumerableValues)
            {
                arrAsString += FormatObject(o);
                arrAsString += ",";
            }

            arrAsString = arrAsString.TrimEnd(',', ' ');
            arrAsString += " }";

            return arrAsString;
        }

        /// <summary>
        /// Colllect all of the properties associated with an attribute.
        /// </summary>
        /// <param name="attribMethodSymbol">The symbol that represents the attribute constructor method.</param>
        /// <param name="attributeData">Contains the values associated with the attribute constructor method properties.</param>
        /// <returns></returns>
        private static IDictionary<string, object> GetAttributeProperties(IMethodSymbol attribMethodSymbol, AttributeData attributeData, GeneratorExecutionContext context)
        {
            Dictionary<string, object> argumentData = new();
            if (attributeData.ConstructorArguments.Any())
            {
                LoadConstructorArguments(attribMethodSymbol, attributeData, context, argumentData);
            }

            foreach (var namedArgument in attributeData.NamedArguments)
            {
                if (namedArgument.Value.Value != null)
                {
                    if (String.Equals(namedArgument.Key, Constants.IsBatchedKey))
                    {
                        var argValue = (bool)namedArgument.Value.Value; // isBatched only takes in booleans and the generator will parse it as a bool so we can type cast this to use in the next line

                        if (argValue)
                        {
                            argumentData["Cardinality"] = "Many";
                        }
                        else
                        {
                            argumentData["Cardinality"] = "One";
                        }
                    }
                    else
                    {
                        argumentData[namedArgument.Key] = namedArgument.Value.Value;
                    }
                }
            }

            return argumentData;
        }

        /// <summary>
        /// Created on demand before each generation pass
        /// </summary>
        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<MethodDeclarationSyntax> CandidateMethods { get; } = new List<MethodDeclarationSyntax>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is MethodDeclarationSyntax methodSyntax)
                {
                    if (methodSyntax.AttributeLists.Count > 0) // collect all methods with attributes - we will verify they are functions when we have access to symbols to get the full name
                    {
                        CandidateMethods.Add(methodSyntax); 
                    }
                }
            }
        }

        private static void WriteGetFunctionsMetadataAsyncMethod(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation, GeneratorExecutionContext context)
        {
            indentedTextWriter.WriteLine("public Task<ImmutableArray<IFunctionMetadata>> GetFunctionMetadataAsync(string directory)");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;

            // create list of IFunctionMetadata and populate it
            indentedTextWriter.WriteLine("var metadataList = new List<IFunctionMetadata>();");
            AddFunctionMetadataInfo(indentedTextWriter, receiver, compilation, context);
            indentedTextWriter.WriteLine("return Task.FromResult(metadataList.ToImmutableArray());");

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        /// <summary>
        /// Checks that a candidate method has a Function attribute then proceeds to create a DefaultFunctionMetadata object.
        /// </summary>
        private static void AddFunctionMetadataInfo(IndentedTextWriter indentedTextWriter, SyntaxReceiver receiver, Compilation compilation, GeneratorExecutionContext context)
        {
            var assemblyName = compilation.Assembly.Name;
            var scriptFile = Path.Combine(assemblyName + ".dll");

            // Loop through the candidate methods (methods with any attribute associated with them)
            foreach (MethodDeclarationSyntax method in receiver.CandidateMethods)
            {
                var model = compilation.GetSemanticModel(method.SyntaxTree);
                
                if(!IsMethodAzureFunction(model, method, context))
                {
                    continue;
                }

                var functionClass = (ClassDeclarationSyntax)method.Parent!;
                var functionName = functionClass.Identifier.ValueText;
                var entryPoint = assemblyName + "." + functionName + "." + method.Identifier.ValueText;
                var bindingsListName = functionName + "RawBindings";

                // collect Bindings
                indentedTextWriter.WriteLine($"var {bindingsListName} = new List<string>();");
                AddBindingInfo(indentedTextWriter, method, model, functionName, context);
                indentedTextWriter.WriteLine($"var {functionName} = new DefaultFunctionMetadata");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;
                indentedTextWriter.WriteLine("FunctionId = Guid.NewGuid().ToString(),");
                indentedTextWriter.WriteLine("Language = \"dotnet-isolated\",");
                indentedTextWriter.WriteLine($"Name = \"{functionName}\",");
                indentedTextWriter.WriteLine($"EntryPoint = \"{entryPoint}\",");
                indentedTextWriter.WriteLine($"RawBindings = {functionName}RawBindings,");
                indentedTextWriter.WriteLine($"ScriptFile = \"{scriptFile}\""); 
                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("};");
                indentedTextWriter.WriteLine($"metadataList.Add({functionName});");
            }
        }

        private static void AddBindingInfo(IndentedTextWriter indentedTextWriter, MethodDeclarationSyntax method, SemanticModel model, string functionName, GeneratorExecutionContext context)
        {
            AddMethodOutputBinding(indentedTextWriter, method, model, functionName, context, out bool hasOutputBinding);
            AddParameterInputAndTriggerBindings(indentedTextWriter, method, model, functionName, context, out bool hasHttpTrigger);
            AddReturnTypeBindings(indentedTextWriter, method, model, functionName, context, hasHttpTrigger, hasOutputBinding);
        }

        /// <summary>
        /// Only an Output Binding can be an attribute on a Function method. This method will check if there is one and return it.
        /// </summary>
        /// <exception cref="FormatException">Throws if attributes are formatted or used incorrectly.</exception>
        private static void AddMethodOutputBinding(IndentedTextWriter indentedTextWriter, MethodDeclarationSyntax method, SemanticModel model, string funcName, GeneratorExecutionContext context, out bool hasOutputBinding)
        {
            var methodSymbol = model.GetDeclaredSymbol(method);
            var attributes = methodSymbol!.GetAttributes(); // methodSymbol is not null here because it's checked in IsMethodAFunction which is called before bindings are collected/created

            AttributeData? outputBinding = null;
            hasOutputBinding = false;

            foreach (var attribute in attributes)
            {
                if (IsBindingAttribute(attribute))
                {
                    if (hasOutputBinding)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MultipleBindingsOnAttribute, Location.None, method.ToString()));
                        return;
                    }

                    outputBinding = attribute;
                    hasOutputBinding = true;
                }
            }

            if (outputBinding != null)
            {
                WriteBindingToFile(indentedTextWriter, outputBinding, funcName, context, Constants.ReturnBindingName, null);
            }
        }

        /// <summary>
        /// This method adds the input/trigger bindings found in the parameters of the Function
        /// </summary>
        /// <exception cref="InvalidOperationException">Throws when a symbol cannot be found.</exception>
        /// <exception cref="FormatException">Throws if the attributes were used and formatted incorrectly.</exception>
        private static void AddParameterInputAndTriggerBindings(IndentedTextWriter indentedTextWriter, MethodDeclarationSyntax method, SemanticModel model, string funcName, GeneratorExecutionContext context, out bool hasHttpTrigger)
        {
            hasHttpTrigger = false;

            foreach (ParameterSyntax parameter in method.ParameterList.Parameters)
            {
                // If there's no attribute, we can assume that this parameter is not a binding
                if (parameter.AttributeLists.Count == 0)
                {
                    continue;
                }

                IParameterSymbol? parameterSymbol = model.GetDeclaredSymbol(parameter);

                if (parameterSymbol is null)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.SymbolNotFound, Location.None, nameof(parameterSymbol)));
                    return;
                }

                // Check to see if any of the attributes associated with this parameter is a BindingAttribute
                foreach (var attribute in parameterSymbol.GetAttributes())
                {
                    if (IsBindingAttribute(attribute))
                    {
                        string? dataType = null;

                        if (IsHttpTrigger(attribute))
                        {
                            hasHttpTrigger = true;
                        }
                        else if (IsEventHubsTrigger(attribute))
                        {
                            if (!IsEventHubsTriggerValid(parameterSymbol, attribute, out dataType)) // we need the parameterSymbol to validate the EventHubs trigger, so we'll validate it at this step
                            {
                                // report diagnostic error
                            }
                        }

                        if (dataType is null)
                        {
                            dataType = parameterSymbol.Type.GetDataTypeFromType();
                        }

                        string bindingName = parameter.Identifier.ValueText;

                        WriteBindingToFile(indentedTextWriter, attribute, funcName, context, bindingName, dataType);
                    }
                }
            }
        }


        /// <summary>
        /// Adds bindings found in the ReturnType class of the Function
        /// </summary>
        private static void AddReturnTypeBindings(IndentedTextWriter indentedTextWriter, MethodDeclarationSyntax method, SemanticModel model, string funcName, GeneratorExecutionContext context, bool hasHttpTrigger, bool hasOutputBinding)
        {
            TypeSyntax returnTypeSyntax = method.ReturnType;
            ITypeSymbol? returnTypeSymbol = model.GetSymbolInfo(returnTypeSyntax).Symbol as ITypeSymbol;

            if (returnTypeSymbol is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.SymbolNotFound, Location.None, nameof(returnTypeSymbol)));
                return;
            }

            if (returnTypeSymbol != null &&
                !String.Equals(returnTypeSymbol.GetFullName(), Constants.VoidType, StringComparison.Ordinal) &&
                !String.Equals(returnTypeSymbol.GetFullName(), Constants.TaskType, StringComparison.Ordinal))
            {
                if(String.Equals(returnTypeSymbol.GetFullName(), Constants.TaskGenericType, StringComparison.Ordinal)) // If there is a Task<T> return type, inspect T, the inner type.
                {
                    GenericNameSyntax genericSyntax = (GenericNameSyntax) returnTypeSyntax;
                    var innerTypeSyntax = genericSyntax.TypeArgumentList.Arguments.First(); // Generic task should only have one type argument
                    returnTypeSymbol = model.GetSymbolInfo(innerTypeSyntax).Symbol as ITypeSymbol;

                    if (returnTypeSymbol is null)
                    {
                        throw new FormatException("Symbol can't be found.");
                    }
                }
                if (String.Equals(returnTypeSymbol.GetFullName(), Constants.HttpResponseType, StringComparison.Ordinal)) // If return type is HttpResponseData
                {
                    AddHttpReturnBinding(indentedTextWriter, funcName, Constants.ReturnBindingName);
                    hasOutputBinding = true;
                }
                else
                {
                    // Check all the members(properties) of this return type class to see if any of them have a binding attribute associated
                    var members = returnTypeSymbol.GetMembers();
                    var foundHttpOutput = false;

                    foreach (var m in members)
                    {
                        if (m.GetAttributes().Length > 0)
                        {
                            var foundPropertyOutputAttr = false;

                            foreach (var attr in m.GetAttributes())
                            {
                                if (IsBindingAttribute(attr))
                                {
                                    if (foundPropertyOutputAttr)
                                    {
                                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MultipleBindingsOnProperty, Location.None, new object[] { nameof(m), nameof(returnTypeSymbol) }));
                                        return;
                                    }

                                    // Check if this attribute is an HttpResponseData type attribute
                                    if (String.Equals(returnTypeSymbol.GetFullName(), Constants.HttpResponseType, StringComparison.Ordinal))
                                    {
                                        if (foundHttpOutput)
                                        {
                                            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MultipleHttpResponseTypes, Location.None, new object[] { Constants.HttpResponseType, nameof(returnTypeSymbol) }));
                                            return;
                                        }

                                        foundHttpOutput = true;
                                        AddHttpReturnBinding(indentedTextWriter, funcName, m.Name);
                                    }
                                    else
                                    {
                                        IPropertySymbol? propertySymbol = m as IPropertySymbol;

                                        if (propertySymbol is null)
                                        {
                                            throw new InvalidOperationException($"The property '{nameof(propertySymbol)}' is invalid.");
                                        }

                                        string? dataType = propertySymbol.Type.GetDataTypeFromType();
                                        WriteBindingToFile(indentedTextWriter, attr, funcName, context, m.Name, dataType);
                                    }

                                    hasOutputBinding = true;
                                    foundPropertyOutputAttr = true;
                                }
                            }

                        }
                    }

                    // No output bindings found in the return type.
                    if (hasHttpTrigger)
                    {
                        if (!hasOutputBinding)
                        {
                            AddHttpReturnBinding(indentedTextWriter, funcName, Constants.ReturnBindingName);
                        }
                        else
                        {
                            AddHttpReturnBinding(indentedTextWriter, funcName, Constants.HttpResponseBindingName);
                        }    
                    }
                }
            }
        }

        /// <summary>
        /// Adds HttpReturn binding.
        /// </summary>
        private static void AddHttpReturnBinding(IndentedTextWriter indentedTextWriter, string funcName, string bindingName)
        {
            indentedTextWriter.WriteLine($"var {funcName}{bindingName.Replace("$", "")}Binding = new {{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine($"name = \"{bindingName}\",");
            indentedTextWriter.WriteLine("type = \"http\",");
            indentedTextWriter.WriteLine("direction = \"Out\",");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("};");

            SerializeAnonymousBindingAsJsonString(indentedTextWriter, funcName, bindingName.Replace("$", ""));
        }

        /// <summary>
        /// This method parses attribute data and symbol info to collect information needed to construct a binding. It then calls a method that will write the binding to the file.
        /// </summary>
        private static void WriteBindingToFile(IndentedTextWriter indentedTextWriter, AttributeData bindingAttrData, string funcName, GeneratorExecutionContext context, string bindingName, string? dataType)
        {
            IMethodSymbol? attribMethodSymbol = bindingAttrData.AttributeConstructor;

            // Check if the attribute constructor has any parameters
            if (attribMethodSymbol is null || attribMethodSymbol?.Parameters is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.SymbolNotFound, Location.None, nameof(attribMethodSymbol)));
                return;
            }

            // Get binding info as a dictionary with keys as the property name and value as the property value
            IDictionary<string, object> attributeProperties = GetAttributeProperties(attribMethodSymbol, bindingAttrData, context);

            if(dataType != null && !attributeProperties.ContainsKey("dataType")) // in some cases, dataType can be added from GetAttributeProperties so make sure dataType hasn't been added yet
            {
                attributeProperties.Add("dataType", dataType); // add data type from the parameter passed into this method
            }

            // Grab some required binding info properties
            string attributeName = bindingAttrData.AttributeClass!.Name;

            // properly format binding types by removing "Attribute" and "Input" descriptors
            string bindingType = attributeName.TrimStringsFromEnd(new string[] { "Attribute", "Input", "Output"});

            // Set binding direction
            string bindingDirection = IsOutputBindingAttribute(bindingAttrData) ? "Out" : "In";

            CreateBindingInfo(indentedTextWriter, funcName, bindingName, bindingType, bindingDirection, attributeProperties);
        }

        /// <summary>
        /// Writes binding info to the generated file. This method takes care of all bindings except for auto-added http return types.
        /// </summary>
        private static void CreateBindingInfo(IndentedTextWriter indentedTextWriter, string functionName, string bindingName, string bindingType, string bindingDirection, IDictionary<string, object> attributeProperties)
        {
            // Create raw binding anonymous type, example:
            /*  var binding1 = new {
                name = "req",
                type = "HttpTrigger",
                direction = "In",
                authLevel = Enum.GetName(typeof(AuthorizationLevel),0),
                methods = new List<string> { "get","post" },
            };*/
            indentedTextWriter.WriteLine($"var {functionName}{bindingName}Binding = new {{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine($"name = \"{bindingName}\",");
            indentedTextWriter.WriteLine($"type = \"{bindingType}\",");
            indentedTextWriter.WriteLine($"direction = \"{bindingDirection}\",");

            // Add additional bindingInfo to the anonymous type because some functions have more properties than others
            foreach (var prop in attributeProperties)
            {
                var propertyName = prop.Key;

                if (prop.Value.GetType().IsArray)
                {
                    string arr = FormatArray((IEnumerable)prop.Value);
                    indentedTextWriter.WriteLine($"{propertyName} = {arr},");
                }
                else
                {
                    var propertyValue = FormatObject(prop.Value);
                    indentedTextWriter.WriteLine($"{propertyName} = {propertyValue},");
                }
            }

            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("};");

            // Take the anonymous type representing the binding and serialize it as a JSON string
            SerializeAnonymousBindingAsJsonString(indentedTextWriter, functionName, bindingName);
        }

        private static void SerializeAnonymousBindingAsJsonString(IndentedTextWriter indentedTextWriter, string functionName, string bindingName)
        {
            indentedTextWriter.WriteLine($"var {functionName}{bindingName}BindingJSONstring = JsonSerializer.Serialize({functionName}{bindingName}Binding);");
            indentedTextWriter.WriteLine($"{functionName}RawBindings.Add({functionName}{bindingName}BindingJSONstring);");
        }

        /// <summary>
        /// Auto-add an enum type used to parse enum values found in user code.
        /// </summary>
        /// <param name="indentedTextWriter"></param>
        private static void AddEnumTypes(IndentedTextWriter indentedTextWriter)
        {
            indentedTextWriter.WriteLine("public enum AuthorizationLevel");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("Anonymous,");
            indentedTextWriter.WriteLine("User,");
            indentedTextWriter.WriteLine("Function,");
            indentedTextWriter.WriteLine("System,");
            indentedTextWriter.WriteLine("Admin");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        /// <summary>
        /// Adds a generated registration extension that users can call to register the source-generated function metadata provider.
        /// </summary>
        private static void AddRegistrationExtension(IndentedTextWriter indentedTextWriter)
        {
            indentedTextWriter.WriteLine("public static class WorkerHostBuilderFunctionMetadataProviderExtension");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("public static IHostBuilder ConfigureGeneratedFunctionMetadataProvider(this IHostBuilder builder)");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("builder.ConfigureServices(s => ");
            indentedTextWriter.WriteLine("{");
            indentedTextWriter.Indent++;
            indentedTextWriter.WriteLine("s.AddSingleton<IFunctionMetadataProvider, GeneratedFunctionMetadataProvider>();");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("});");
            indentedTextWriter.WriteLine("return builder;");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
            indentedTextWriter.Indent--;
            indentedTextWriter.WriteLine("}");
        }

        /// <summary>
        /// This method verifies that an EventHubsTrigger matches our expectations on cardinality (isBatched property). If isBatched is set to true, the parameter with the
        /// attriute must be an enumerabletype.
        /// </summary>
        private static bool IsEventHubsTriggerValid(IParameterSymbol parameterSymbol, AttributeData attribute, out string? dataType)
        {
            dataType = null;

            foreach (var arg in attribute.NamedArguments)
            {
                if(String.Equals(arg.Key, Constants.IsBatchedKey) &&
                    arg.Value.Value != null)
                {
                    var isBatched = (bool)arg.Value.Value; // isBatched takes in booleans so we can just type cast it here to use
                    
                    if (isBatched) // if isBatched is true, then we need to check that this parameter is an iterable collection
                    {
                        var parameterSymbolFullName = parameterSymbol.Type.GetFullName();
                        bool isArray = parameterSymbol.Type is IArrayTypeSymbol;

                        if (isArray && !string.Equals(parameterSymbolFullName, Constants.ByteArrayType, StringComparison.Ordinal)) // we exclude ByteArrayType (byte[]) which is treated as a single object, not an iterable collection
                        {
                            dataType = parameterSymbol.Type.GetDataTypeFromType();
                            return true;
                        }

                        bool isMappingEnumerable = parameterSymbol.IsOrDerivedFrom(Constants.IEnumerableOfKeyValuePair)
                            || parameterSymbol.IsOrDerivedFrom(Constants.LookupGenericType)
                            || parameterSymbol.IsOrDerivedFrom(Constants.DictionaryGenericType);
                        if (isMappingEnumerable)
                        {
                            return false;
                        }

                        // IEnumerable and not string or dictionary
                        bool isEnumerableOfT = parameterSymbol.IsOrDerivedFrom(Constants.IEnumerableOfT);
                        bool isEnumerableCollection = !parameterSymbol.Type.IsStringType()
                            && (parameterSymbol.IsOrDerivedFrom(Constants.IEnumerableType)
                            || parameterSymbol.IsOrDerivedFrom(Constants.IEnumerableGenericType)
                            || isEnumerableOfT);
                        if (isEnumerableCollection)
                        {
                            if (parameterSymbol.IsOrDerivedFrom(Constants.IEnumerableOfStringType))
                            {
                                dataType = "\"String\"";
                            }
                            else if (parameterSymbol.IsOrDerivedFrom(Constants.IEnumerableOfBinaryType))
                            {
                                dataType = "\"Binary\"";
                            }
                            else if (isEnumerableOfT)
                            {
                                dataType = ResolveIEnumerableOfT(parameterSymbol);
                                return true;
                            }
                            return true;
                        }

                        return false;
                    }
                }
            }

            // no isBatched property was found so return true
            return true;
        }

        private static string ResolveIEnumerableOfT(IParameterSymbol parameterSymbol)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Checks if a method is a function by using its full name.
        /// </summary>
        private static bool IsMethodAzureFunction(SemanticModel model, MethodDeclarationSyntax method, GeneratorExecutionContext context)
        {
            var methodSymbol = model.GetDeclaredSymbol(method);

            if (methodSymbol is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.SymbolNotFound, Location.None, nameof(methodSymbol)));
                return false;
            }

            foreach (var attr in methodSymbol.GetAttributes())
            {
                if (attr.AttributeClass != null &&
                   String.Equals(attr.AttributeClass.GetFullName(), Constants.FunctionNameType))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Determines whether an attribute is a Function Binding or not. This method assumes that any Function Binding related attributes passed in are
        /// of the highest level (specific bindings like QueueTrigger, Queue Input Binding, etc).
        /// </summary>
        /// <param name="attribute">The exact attribute decorating a method/parameter/property declaration.</param>
        private static bool IsBindingAttribute(AttributeData attribute)
        {
            if (attribute.AttributeClass?.BaseType?.BaseType is not null)
            {
                return String.Equals(attribute.AttributeClass.BaseType.BaseType.GetFullName(), Constants.BindingAttributeType);
            }

            return false;
        }

        /// <summary>
        /// Determines whether an attribute is a Function OutputBinding or not. This method assumes that any Function Binding related attributes passed in are
        /// of the highest level (specific bindings like QueueTrigger, Queue Input Binding, etc).
        /// </summary>
        /// <param name="attribute">The exact attribute decorating a method/parameter/property declaration.</param>
        private static bool IsOutputBindingAttribute(AttributeData attribute)
        {
            if (attribute.AttributeClass?.BaseType != null)
            {
                return String.Equals(attribute.AttributeClass.BaseType.GetFullName(), Constants.OutputBindingAttributeType);
            }

            return false;
        }

        /// <summary>
        /// Determines whether an attribute is an HttpTrigger or not. This method assumes that any Function Binding related attributes passed in are
        /// of the highest level (specific bindings like QueueTrigger, Queue Input Binding, etc).
        /// </summary>
        /// <param name="attribute">The exact attribute decorating a method/parameter/property declaration.</param>
        private static bool IsHttpTrigger(AttributeData attribute)
        {
            if (attribute.AttributeClass != null)
            {
                return String.Equals(attribute.AttributeClass.GetFullName(), Constants.HttpTriggerBindingType);
            }

            return false;
        }

        private static bool IsEventHubsTrigger(AttributeData attribute)
        {
            if (attribute.AttributeClass != null)
            {
                return String.Equals(attribute.AttributeClass.GetFullName(), Constants.EventHubsTriggerType);
            }

            return false;
        }
    }
}
