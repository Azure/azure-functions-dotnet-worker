// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System.Globalization;
using System.IO.Abstractions;
using System.Text;
using System.Xml;
using Microsoft.Build.Framework;
using NuGet.ProjectModel;

namespace Azure.Functions.Sdk.Tasks.Extensions;

public class WriteExtensionProject(IFileSystem fileSystem, TimeProvider time)
    : Microsoft.Build.Utilities.Task
{
    // Has empty new-lines to work with XmlWriter.WriteComment.
    private const string Disclaimer =
        """

        <autogenerated>
          This file is auto-generated by a tool.

          Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
          Generated at: {0:u}; Packages hash: {1}
        </autogenerated>

        """;

    private static readonly XmlWriterSettings _xmlSettings = new()
    {
        Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false),
        Indent = true,
        IndentChars = "  ",
        NewLineChars = "\n",
        NewLineHandling = NewLineHandling.Replace,
        OmitXmlDeclaration = true,
    };

    private readonly IFileSystem _fileSystem = Throw.IfNull(fileSystem);
    private readonly TimeProvider _time = Throw.IfNull(time);

    public WriteExtensionProject()
        : this(new FileSystem(), TimeProvider.System)
    {
    }

    [Required]
    public ITaskItem[] ExtensionPackages { get; set; } = [];

    [Required]
    public string ProjectPath { get; set; } = string.Empty;

    public string? HashFilePath { get; set; }

    public override bool Execute()
    {
        string hash = CalculateHash();
        if (!ShouldRun(hash))
        {
            return true;
        }

        _fileSystem.File.Delete(ProjectPath);
        using Stream stream = _fileSystem.File.OpenWrite(ProjectPath);
        using XmlWriter writer = XmlWriter.Create(stream, _xmlSettings);
        writer.WriteComment(string.Format(CultureInfo.InvariantCulture, Disclaimer, _time.GetUtcNow(), hash));
        writer.WriteStartElement("Project");

        // Omit version so the outer projects version is implicitly used.
        writer.WriteAttributeString("Sdk", ThisAssembly.Name);

        if (ExtensionPackages.Length > 0)
        {
            writer.WriteStartElement("ItemGroup");

            foreach (ITaskItem package in ExtensionPackages)
            {
                writer.WriteStartElement("PackageReference");
                writer.WriteAttributeString("Include", package.ItemSpec);
                writer.WriteAttributeString("Version", package.GetVersion());
                writer.WriteEndElement();
            }

            writer.WriteEndElement();
        }

        writer.WriteEndElement();
        UpdateHash(hash);
        return true;
    }

    private bool ShouldRun(string currentHash)
    {
        if (string.IsNullOrEmpty(HashFilePath)
            || !_fileSystem.File.Exists(HashFilePath)
            || !_fileSystem.File.Exists(ProjectPath))
        {
            Log.LogMessage(MessageImportance.Low, Strings.ExtensionProject_DoesNotExist);
            return true;
        }

        string existingHash = _fileSystem.File.ReadAllText(HashFilePath);
        if (existingHash != currentHash)
        {
            Log.LogMessage(MessageImportance.Low, Strings.ExtensionProject_HashOutOfDate, existingHash, currentHash);
            return true;
        }
        else
        {
            Log.LogMessage(MessageImportance.Low, Strings.ExtensionProject_HashUpToDate, existingHash);
            return false;
        }
    }

    private void UpdateHash(string hash)
    {
        if (string.IsNullOrEmpty(HashFilePath))
        {
            return;
        }

        _fileSystem.File.WriteAllText(HashFilePath!, hash);
        Log.LogMessage(MessageImportance.Low, Strings.ExtensionProject_FinishedGenerating, hash);
    }

    /// <summary>
    /// Calculates the hash of the current set of extension packages. This is used to determine
    /// if the extension project needs to be regenerated.
    /// </summary>
    /// <returns>The calculated hash.</returns>
    /// <remarks>
    /// The hash calculation uses the following as input:
    /// - The tooling generating the hash itself (so any change to tooling forces a project update).
    /// - The list of extension packages (identity and version).
    /// </remarks>
    private string CalculateHash()
    {
        using FnvHash64Function algorithm = new();
        using HashObjectWriter hash = new(algorithm);

        // Verify if the tooling has changed.
        hash.WriteNameValue("version", ThisAssembly.Version.ToString());
        hash.WriteNameValue("moduleId", ThisAssembly.ModuleVersionId);

        hash.WriteArrayStart("packages");
        foreach (ITaskItem item in ExtensionPackages)
        {
            hash.WriteObjectStart();
            hash.WriteNameValue("identity", item.ItemSpec);
            hash.WriteNameValue("version", item.GetMetadata("Version"));
            hash.WriteObjectEnd();
        }

        hash.WriteArrayEnd();

        return hash.GetHash();
    }
}
