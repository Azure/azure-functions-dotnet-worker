// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System.IO.Abstractions;
using System.Text;
using Microsoft.Build.Framework;
using NuGet.ProjectModel;

namespace Azure.Functions.Sdk.Tasks.Extensions;

public class WriteExtensionProject(IFileSystem fileSystem, TimeProvider time)
    : Microsoft.Build.Utilities.Task
{
    private const string Disclaimer = @"<!--
  <autogenerated>
    This file is auto-generated by a tool.

    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
    Generated at: {0:yyyy-MM-dd HH:mm:ss zzz}; Packages hash: {1}
  </autogenerated>
-->";

    private readonly IFileSystem _fileSystem = Throw.IfNull(fileSystem);
    private readonly TimeProvider _time = Throw.IfNull(time);

    public WriteExtensionProject()
        : this(new FileSystem(), TimeProvider.System)
    {
    }

    [Required]
    public ITaskItem[] ExtensionPackages { get; set; } = [];

    [Required]
    public string ProjectPath { get; set; } = string.Empty;

    public string? HashFilePath { get; set; }

    public override bool Execute()
    {
        string hash = CalculateHash();
        if (!ShouldRun(hash))
        {
            return true;
        }

        _fileSystem.File.Delete(ProjectPath);
        using Stream stream = _fileSystem.File.OpenWrite(ProjectPath);
        using StreamWriter writer = new(stream, Encoding.UTF8);
        writer.WriteLine(Disclaimer, _time.GetUtcNow(), hash);
        writer.WriteLine();
        writer.WriteLine($"<Project Sdk=\"{ThisAssembly.Name}\">");
        writer.WriteLine();

        writer.WriteLine($"  <ItemGroup>");
        foreach (ITaskItem package in ExtensionPackages)
        {
            writer.WriteLine($"    <PackageReference Include=\"{package.ItemSpec}\" Version=\"{package.GetMetadata("Version")}\" />");
        }

        writer.WriteLine("  </ItemGroup>");
        writer.WriteLine();
        writer.WriteLine("</Project>");

        UpdateHash(hash);
        return true;
    }

    private bool ShouldRun(string currentHash)
    {
        if (string.IsNullOrEmpty(HashFilePath)
            || !_fileSystem.File.Exists(HashFilePath)
            || !_fileSystem.File.Exists(ProjectPath))
        {
            Log.LogMessage(
                MessageImportance.Low,
                "Hash file does not exist or project file does not exist. Regenerating project.");
            return true;
        }

        string existingHash = _fileSystem.File.ReadAllText(HashFilePath);
        if (existingHash != currentHash)
        {
            Log.LogMessage(
                MessageImportance.Low,
                "Existing hash '{0}' does not match current hash '{1}'. Regenerating project.",
                existingHash,
                currentHash);
            return true;
        }
        else
        {
            Log.LogMessage(
                MessageImportance.Low,
                "Existing hash '{0}' matches current hash '{1}'. No changes detected, skipping project generation.",
                existingHash,
                currentHash);
            return false;
        }
    }

    private void UpdateHash(string hash)
    {
        if (string.IsNullOrEmpty(HashFilePath))
        {
            return;
        }

        _fileSystem.File.WriteAllText(HashFilePath!, hash);
        Log.LogMessage(
            MessageImportance.Low,
            "Finished generating project. Updated cache file with hash '{0}'.",
            hash);
    }

    private string CalculateHash()
    {
        using FnvHash64Function algorithm = new();
        using HashObjectWriter hash = new(algorithm);

        // Verify if the tooling has changed.
        hash.WriteNameValue("version", ThisAssembly.Version.ToString());
        hash.WriteNameValue("moduleId", ThisAssembly.ModuleVersionId);

        hash.WriteArrayStart("packages");
        foreach (ITaskItem item in ExtensionPackages)
        {
            hash.WriteObjectStart();
            hash.WriteNameValue("identity", item.ItemSpec);
            hash.WriteNameValue("version", item.GetMetadata("Version"));
            hash.WriteObjectEnd();
        }

        hash.WriteArrayEnd();

        return hash.GetHash();
    }
}
