// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System.Reflection;
using System.Threading.Tasks;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Sdk.Generators;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Xunit;

namespace Microsoft.Azure.Functions.SdkGeneratorTests
{
    public class FunctionExecutorGeneratorTests
    {
        private const string ExpectedExtensionMethodCode = @"public static class FunctionExecutorHostBuilderExtensions
    {
        ///<summary>
        /// Configures an optimized function executor to the invocation pipeline.
        ///</summary>
        public static IHostBuilder ConfigureGeneratedFunctionExecutor(this IHostBuilder builder)
        {
            return builder.ConfigureServices(s => 
            {
                s.AddSingleton<IFunctionExecutor, DirectFunctionExecutor>();
            });
        }
    }";

        // A super set of assemblies we need for all tests in the file.
        private readonly Assembly[] _referencedAssemblies = new[]
        {
            typeof(HttpTriggerAttribute).Assembly,
            typeof(FunctionAttribute).Assembly,
            typeof(QueueTriggerAttribute).Assembly,
            typeof(BlobInputAttribute).Assembly,
            typeof(LoggingServiceCollectionExtensions).Assembly,
            typeof(ServiceProviderServiceExtensions).Assembly,
            typeof(ServiceCollection).Assembly,
            typeof(ILogger).Assembly,
            typeof(IConfiguration).Assembly,
            typeof(HostBuilder).Assembly,
            typeof(IHostBuilder).Assembly
        };

        [Fact]
        public async Task FunctionsFromMultipleClasses()
        {
            const string inputSourceCode = @"
using System;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
namespace MyCompany
{
    public class MyHttpTriggers
    {
        [Function(""FunctionA"")]
        public HttpResponseData Foo([HttpTrigger(AuthorizationLevel.User, ""get"")] HttpRequestData r, FunctionContext c)
        {
            return r.CreateResponse(System.Net.HttpStatusCode.OK);
        }
        
        private int Foo(int x) => x * x;
    }
    public class MyHttpTriggers2
    {
        [Function(""FunctionB"")]
        public HttpResponseData Bar([HttpTrigger(AuthorizationLevel.User, ""get"")] HttpRequestData r)
        {
            return r.CreateResponse(System.Net.HttpStatusCode.OK);
        }
        
        private int Foo(int x) => x * x;
    }
    public static class Foo
    {
        [Function(""ProcessOrder2"")]
        public static async Task<string> MyAsyncStaticMethod([QueueTrigger(""foo"")] string q) => q;
    }
}
";
            var expectedOutput = $@"// <auto-generated/>
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Azure.Functions.Worker.Context.Features;
using Microsoft.Azure.Functions.Worker.Invocation;
namespace Microsoft.Azure.Functions.Worker
{{
    internal class DirectFunctionExecutor : IFunctionExecutor
    {{
        private readonly IFunctionActivator _functionActivator;
        private readonly Dictionary<string, Type> types = new()
        {{
            {{ ""MyCompany.MyHttpTriggers"", Type.GetType(""MyCompany.MyHttpTriggers"")! }},
            {{ ""MyCompany.MyHttpTriggers2"", Type.GetType(""MyCompany.MyHttpTriggers2"")! }}
        }};

        public DirectFunctionExecutor(IFunctionActivator functionActivator)
        {{
            _functionActivator = functionActivator ?? throw new ArgumentNullException(nameof(functionActivator));
        }}

        public async ValueTask ExecuteAsync(FunctionContext context)
        {{
            var inputBindingFeature = context.Features.Get<IFunctionInputBindingFeature>()!;
            var inputBindingResult = await inputBindingFeature.BindFunctionInputAsync(context)!;
            var inputArguments = inputBindingResult.Values;

            if (string.Equals(context.FunctionDefinition.EntryPoint, ""MyCompany.MyHttpTriggers.Foo"", StringComparison.OrdinalIgnoreCase))
            {{
                var instanceType = types[""MyCompany.MyHttpTriggers""];
                var i = _functionActivator.CreateInstance(instanceType, context) as MyCompany.MyHttpTriggers;
                context.GetInvocationResult().Value = i.Foo((Microsoft.Azure.Functions.Worker.Http.HttpRequestData)inputArguments[0], (Microsoft.Azure.Functions.Worker.FunctionContext)inputArguments[1]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""MyCompany.MyHttpTriggers2.Bar"", StringComparison.OrdinalIgnoreCase))
            {{
                var instanceType = types[""MyCompany.MyHttpTriggers2""];
                var i = _functionActivator.CreateInstance(instanceType, context) as MyCompany.MyHttpTriggers2;
                context.GetInvocationResult().Value = i.Bar((Microsoft.Azure.Functions.Worker.Http.HttpRequestData)inputArguments[0]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""MyCompany.Foo.MyAsyncStaticMethod"", StringComparison.OrdinalIgnoreCase))
            {{
                context.GetInvocationResult().Value = await MyCompany.Foo.MyAsyncStaticMethod((string)inputArguments[0]);
            }}
        }}
    }}
    {ExpectedExtensionMethodCode}
}}".Replace("'", "\"");

            await TestHelpers.RunTestAsync<Worker.Sdk.Generators.FunctionExecutorGenerator>(
                _referencedAssemblies,
                inputSourceCode,
                Constants.FileNames.GeneratedFunctionExecutor,
                expectedOutput);
        }

        [Fact]
        public async Task MultipleFunctionsDependencyInjection()
        {
            string inputSourceCode = @"
using System.Net;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace MyCompany
{
    public class MyHttpTriggers
    {
        private readonly ILogger _logger;
        public MyHttpTriggers(ILoggerFactory loggerFactory)
        {
            _logger = loggerFactory.CreateLogger<MyHttpTriggers>();
        }

        [Function(""Function1"")]
        public HttpResponseData Run1([HttpTrigger(AuthorizationLevel.User, ""get"")] HttpRequestData r)
            => r.CreateResponse(System.Net.HttpStatusCode.OK);

        [Function(""Function2"")]
        public HttpResponseData Run2([HttpTrigger(AuthorizationLevel.User, ""get"")] HttpRequestData r, FunctionContext c)
        {
            return r.CreateResponse(System.Net.HttpStatusCode.OK);
        }

        private int Foo(int x) => x * x;
    }
}
";

            var expectedOutput = @$"// <auto-generated/>
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Azure.Functions.Worker.Context.Features;
using Microsoft.Azure.Functions.Worker.Invocation;
namespace Microsoft.Azure.Functions.Worker
{{
    internal class DirectFunctionExecutor : IFunctionExecutor
    {{
        private readonly IFunctionActivator _functionActivator;
        private readonly Dictionary<string, Type> types = new()
        {{
            {{ ""MyCompany.MyHttpTriggers"", Type.GetType(""MyCompany.MyHttpTriggers"")! }}
        }};

        public DirectFunctionExecutor(IFunctionActivator functionActivator)
        {{
            _functionActivator = functionActivator ?? throw new ArgumentNullException(nameof(functionActivator));
        }}

        public async ValueTask ExecuteAsync(FunctionContext context)
        {{
            var inputBindingFeature = context.Features.Get<IFunctionInputBindingFeature>()!;
            var inputBindingResult = await inputBindingFeature.BindFunctionInputAsync(context)!;
            var inputArguments = inputBindingResult.Values;

            if (string.Equals(context.FunctionDefinition.EntryPoint, ""MyCompany.MyHttpTriggers.Run1"", StringComparison.OrdinalIgnoreCase))
            {{
                var instanceType = types[""MyCompany.MyHttpTriggers""];
                var i = _functionActivator.CreateInstance(instanceType, context) as MyCompany.MyHttpTriggers;
                context.GetInvocationResult().Value = i.Run1((Microsoft.Azure.Functions.Worker.Http.HttpRequestData)inputArguments[0]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""MyCompany.MyHttpTriggers.Run2"", StringComparison.OrdinalIgnoreCase))
            {{
                var instanceType = types[""MyCompany.MyHttpTriggers""];
                var i = _functionActivator.CreateInstance(instanceType, context) as MyCompany.MyHttpTriggers;
                context.GetInvocationResult().Value = i.Run2((Microsoft.Azure.Functions.Worker.Http.HttpRequestData)inputArguments[0], (Microsoft.Azure.Functions.Worker.FunctionContext)inputArguments[1]);
            }}
        }}
    }}
    {ExpectedExtensionMethodCode}
}}".Replace("'", "\"");

            await TestHelpers.RunTestAsync<FunctionExecutorGenerator>(
                _referencedAssemblies,
                inputSourceCode,
                Constants.FileNames.GeneratedFunctionExecutor,
                expectedOutput);
        }

        [Fact]
        public async Task StaticMethods()
        {
            var inputSourceCode = @"
using System;
using System.Threading.Tasks;
using Microsoft.Azure.Functions.Worker;

namespace FunctionApp26
{
    public static class MyQTriggers
    {
        [Function(""ProcessOrder1"")]
        public static Task MyTaskStaticMethod([QueueTrigger(""foo"")] string q)
        {
            return Task.CompletedTask;
        }
        [Function(""ProcessOrder2"")]
        public static async Task<string> MyAsyncStaticMethod([QueueTrigger(""foo"")] string q) => q;

        [Function(""ProcessOrder3"")]
        public static void MyVoidStaticMethod([QueueTrigger(""foo"")] string q)
        {
        }
        [Function(""ProcessOrder4"")]
        public static async Task<int> MyAsyncStaticMethodWithReturn(
                    [QueueTrigger(""foo"")] string q,
                    [BlobInput(""test-samples/sample1.txt"")] string myBlob)
        {
            return q.Length + myBlob.Length;
        }
        [Function(""ProcessOrder5"")]
        public static async ValueTask<string> MyValueTaskOfTStaticAsyncMethod([QueueTrigger(""foo"")] string q)
        {
            return q;
        }
        [Function(""ProcessOrder6"")]
        public static ValueTask MyValueTaskStaticAsyncMethod2([QueueTrigger(""foo"")] string q)
        {
            return ValueTask.CompletedTask;
        }
    }
}".Replace("'", "\"");
            var expectedOutput = @$"// <auto-generated/>
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Azure.Functions.Worker.Context.Features;
using Microsoft.Azure.Functions.Worker.Invocation;
namespace Microsoft.Azure.Functions.Worker
{{
    internal class DirectFunctionExecutor : IFunctionExecutor
    {{
        private readonly IFunctionActivator _functionActivator;
        
        public DirectFunctionExecutor(IFunctionActivator functionActivator)
        {{
            _functionActivator = functionActivator ?? throw new ArgumentNullException(nameof(functionActivator));
        }}

        public async ValueTask ExecuteAsync(FunctionContext context)
        {{
            var inputBindingFeature = context.Features.Get<IFunctionInputBindingFeature>()!;
            var inputBindingResult = await inputBindingFeature.BindFunctionInputAsync(context)!;
            var inputArguments = inputBindingResult.Values;

            if (string.Equals(context.FunctionDefinition.EntryPoint, ""FunctionApp26.MyQTriggers.MyTaskStaticMethod"", StringComparison.OrdinalIgnoreCase))
            {{
                await FunctionApp26.MyQTriggers.MyTaskStaticMethod((string)inputArguments[0]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""FunctionApp26.MyQTriggers.MyAsyncStaticMethod"", StringComparison.OrdinalIgnoreCase))
            {{
                context.GetInvocationResult().Value = await FunctionApp26.MyQTriggers.MyAsyncStaticMethod((string)inputArguments[0]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""FunctionApp26.MyQTriggers.MyVoidStaticMethod"", StringComparison.OrdinalIgnoreCase))
            {{
                FunctionApp26.MyQTriggers.MyVoidStaticMethod((string)inputArguments[0]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""FunctionApp26.MyQTriggers.MyAsyncStaticMethodWithReturn"", StringComparison.OrdinalIgnoreCase))
            {{
                context.GetInvocationResult().Value = await FunctionApp26.MyQTriggers.MyAsyncStaticMethodWithReturn((string)inputArguments[0], (string)inputArguments[1]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""FunctionApp26.MyQTriggers.MyValueTaskOfTStaticAsyncMethod"", StringComparison.OrdinalIgnoreCase))
            {{
                context.GetInvocationResult().Value = await FunctionApp26.MyQTriggers.MyValueTaskOfTStaticAsyncMethod((string)inputArguments[0]);
            }}
            if (string.Equals(context.FunctionDefinition.EntryPoint, ""FunctionApp26.MyQTriggers.MyValueTaskStaticAsyncMethod2"", StringComparison.OrdinalIgnoreCase))
            {{
                await FunctionApp26.MyQTriggers.MyValueTaskStaticAsyncMethod2((string)inputArguments[0]);
            }}
        }}
    }}
    {ExpectedExtensionMethodCode}
}}".Replace("'", "\"");

            await TestHelpers.RunTestAsync<Worker.Sdk.Generators.FunctionExecutorGenerator>(
                _referencedAssemblies,
                inputSourceCode,
                Constants.FileNames.GeneratedFunctionExecutor,
                expectedOutput);
        }
    }
}
