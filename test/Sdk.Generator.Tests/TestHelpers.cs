using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using System.IO;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis.Testing.Verifiers;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Core;

namespace Sdk.Generator.Tests
{
    static class TestHelpers
    {
        public static Task RunTestAsync<TSourceGenerator>(
            string expectedFileName,
            string inputSource,
            string expectedOutputSource,
            bool isDurableFunctions) where TSourceGenerator : ISourceGenerator, new()
        {
            CSharpSourceGeneratorVerifier<TSourceGenerator>.Test test = new()
            {
                TestState =
            {
                Sources = { inputSource },
                GeneratedSources =
                {
                    (typeof(TSourceGenerator), expectedFileName, SourceText.From(expectedOutputSource, Encoding.UTF8, SourceHashAlgorithm.Sha1)),
                },
                AdditionalReferences =
                {
                    // Durable Task SDK
                    ///typeof(TaskActivityContext).Assembly,
                },
            },
            };

            // if (isDurableFunctions)
            {
                // Durable Functions code generation is triggered by the presence of the
                // Durable Functions worker extension for .NET Isolated.
                Assembly functionsWorkerAbstractions = typeof(WorkerExtensionStartupAttribute).Assembly;
                test.TestState.AdditionalReferences.Add(functionsWorkerAbstractions);

                // TO DO: SEe we can write an dummy extrension assembly here.
                Assembly functionsWorkerCore = typeof(HttpTriggerAttribute).Assembly;
                test.TestState.AdditionalReferences.Add(functionsWorkerCore);

                //Assembly durableExtension = typeof(OrchestrationTriggerAttribute).Assembly;
                //test.TestState.AdditionalReferences.Add(durableExtension);

                //Assembly dependencyInjection = typeof(ActivatorUtilities).Assembly;
                //test.TestState.AdditionalReferences.Add(dependencyInjection);
            }

            return test.RunAsync();
        }

        public static string WrapAndFormat(string generatedClassName, string methodList, bool isDurableFunctions = false)
        {
            string formattedMethodList = IndentLines(spaces: 8, methodList);
            string usings = @"
using System;
using System.Threading.Tasks;";

            if (isDurableFunctions)
            {
                usings += @"
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.DependencyInjection;";
            }

            return $@"
// <auto-generated/>
#nullable enable
{usings}
namespace DurableTask
{{
    public static class {generatedClassName}
    {{
        {formattedMethodList.TrimStart()}
    }}
}}
".TrimStart();
        }

        static string IndentLines(int spaces, string multilineText)
        {
            string indent = new(' ', spaces);
            StringBuilder sb = new();

            foreach (string line in multilineText.Trim().Split("\r\n"))
            {
                if (line.Length > 0)
                {
                    sb.Append(indent);
                }

                sb.AppendLine(line);
            }

            return sb.ToString().TrimEnd();
        }

        internal static object DeIndent(string code, int spacesToRemove)
        {
            StringBuilder sb = new(code.Length);
            foreach (string line in code.Split(Environment.NewLine))
            {
                int charsToSkip = Math.Min(spacesToRemove, line.Length);
                sb.AppendLine(line.Substring(charsToSkip));
            }

            return sb.ToString();
        }

        internal static string GetDefaultInputType(string inputType)
        {
            static bool IsValueType(string typeExpression)
            {
                // This list is obviously incomplete, but should be enhanced as necessary for testing
                switch (typeExpression)
                {
                    case "int":
                    case "float":
                    case "double":
                    case "byte":
                    case "Guid":
                    case "TimeSpan":
                    case "DateTime":
                    case "DateTimeOffset":
                        return true;
                    default:
                        Type? runtimeType = Type.GetType(typeExpression, throwOnError: false);
                        return runtimeType != null && runtimeType.IsValueType;
                }
            };

            if (inputType.StartsWith("(") || inputType.EndsWith("?") || IsValueType(inputType))
            {
                return inputType;
            }

            return inputType + "?";
        }
    }

    // Mostly copy/pasted from the Microsoft Source Generators testing documentation
    public static class CSharpSourceGeneratorVerifier<TSourceGenerator> where TSourceGenerator : ISourceGenerator, new()
    {
        public class Test : CSharpSourceGeneratorTest<TSourceGenerator, XUnitVerifier>
        {
            public Test()
            {
                // See https://www.nuget.org/packages/Microsoft.NETCore.App.Ref/6.0.0
                this.ReferenceAssemblies = new ReferenceAssemblies(
                    targetFramework: "net6.0",
                    referenceAssemblyPackage: new PackageIdentity("Microsoft.NETCore.App.Ref", "6.0.0"),
                    referenceAssemblyPath: Path.Combine("ref", "net6.0"));
            }

            public LanguageVersion LanguageVersion { get; set; } = LanguageVersion.CSharp9;

            protected override CompilationOptions CreateCompilationOptions()
            {
                CompilationOptions compilationOptions = base.CreateCompilationOptions();
                return compilationOptions.WithSpecificDiagnosticOptions(
                     compilationOptions.SpecificDiagnosticOptions.SetItems(GetNullableWarningsFromCompiler()));
            }

            static ImmutableDictionary<string, ReportDiagnostic> GetNullableWarningsFromCompiler()
            {
                string[] args = { "/warnaserror:nullable" };
                var commandLineArguments = CSharpCommandLineParser.Default.Parse(
                    args,
                    baseDirectory: Environment.CurrentDirectory,
                    sdkDirectory: Environment.CurrentDirectory);
                var nullableWarnings = commandLineArguments.CompilationOptions.SpecificDiagnosticOptions;

                return nullableWarnings;
            }

            protected override ParseOptions CreateParseOptions()
            {
                return ((CSharpParseOptions)base.CreateParseOptions()).WithLanguageVersion(this.LanguageVersion);
            }
        }
    }
}
